"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRawApi = void 0;
const platform_node_js_1 = require("../platform.node.js");
const error_js_1 = require("./error.js");
const payload_js_1 = require("./payload.js");
const debug = (0, platform_node_js_1.debug)("grammy:core");
// Transformer base functions
function concatTransformer(prev, trans) {
    return (method, payload, signal) => trans(prev, method, payload, signal);
}
class ApiClient {
    constructor(token, options = {}, webhookReplyEnvelope = {}) {
        var _a, _b, _c, _d, _e;
        Object.defineProperty(this, "token", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: token
        });
        Object.defineProperty(this, "webhookReplyEnvelope", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: webhookReplyEnvelope
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "hasUsedWebhookReply", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: false
        });
        Object.defineProperty(this, "installedTransformers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: []
        });
        Object.defineProperty(this, "call", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (method, payload, signal) => {
                debug("Calling", method);
                const url = this.options.buildUrl(this.options.apiRoot, this.token, method);
                const formDataRequired = (0, payload_js_1.requiresFormDataUpload)(payload);
                if (this.webhookReplyEnvelope.send !== undefined &&
                    !this.hasUsedWebhookReply &&
                    !formDataRequired &&
                    this.options.canUseWebhookReply(method)) {
                    this.hasUsedWebhookReply = true;
                    const config = (0, payload_js_1.createJsonPayload)({ ...payload, method });
                    await this.webhookReplyEnvelope.send(config.body);
                    // deno-lint-ignore no-explicit-any
                    return { ok: true, result: true };
                }
                else {
                    const p = payload !== null && payload !== void 0 ? payload : {};
                    const sensLogs = this.options.sensitiveLogs;
                    const abortController = new shim_node_js_1.AbortController();
                    const abort = combineAborts(abortController, signal);
                    const res = await new Promise((resolve, reject) => {
                        function onStreamError(err) {
                            abort();
                            reject(err);
                        }
                        const onHttpError = toHttpError(method, sensLogs, reject);
                        const config = formDataRequired
                            ? (0, payload_js_1.createFormDataPayload)(p, onStreamError)
                            : (0, payload_js_1.createJsonPayload)(p);
                        const opts = {
                            ...this.options.baseFetchConfig,
                            signal: abortController.signal,
                            ...config,
                        };
                        (0, shim_node_js_1.fetch)(url, opts).then((res) => res.json()).then(resolve)
                            .catch(onHttpError);
                    });
                    return res;
                }
            }
        });
        this.options = {
            apiRoot: (_a = options.apiRoot) !== null && _a !== void 0 ? _a : "https://api.telegram.org",
            buildUrl: (_b = options.buildUrl) !== null && _b !== void 0 ? _b : ((root, token, method) => `${root}/bot${token}/${method}`),
            baseFetchConfig: (_c = options.baseFetchConfig) !== null && _c !== void 0 ? _c : platform_node_js_1.baseFetchConfig,
            canUseWebhookReply: (_d = options.canUseWebhookReply) !== null && _d !== void 0 ? _d : (() => false),
            sensitiveLogs: (_e = options.sensitiveLogs) !== null && _e !== void 0 ? _e : false,
        };
        if (this.options.apiRoot.endsWith("/")) {
            throw new Error(`Remove the trailing '/' from the 'apiRoot' option (use '${this.options.apiRoot.substr(0, this.options.apiRoot.length - 1)}' instead of '${this.options.apiRoot}')`);
        }
    }
    use(...transformers) {
        this.call = transformers.reduce(concatTransformer, this.call);
        this.installedTransformers.push(...transformers);
        return this;
    }
    async callApi(method, payload, signal) {
        const data = await this.call(method, payload, signal);
        if (data.ok)
            return data.result;
        else {
            throw new error_js_1.GrammyError(`Call to '${method}' failed!`, data, method, payload);
        }
    }
}
/**
 * Creates a new transformable API, i.e. an object that lets you perform raw API
 * calls to the Telegram Bot API server but pass the calls through a stack of
 * transformers before. This will create a new API client instance under the
 * hood that will be used to connect to the Telegram servers. You therefore need
 * to pass the bot token. In addition, you may pass API client options as well
 * as a webhook reply envelope that allows the client to perform up to one HTTP
 * request in response to a webhook call if this is desired.
 *
 * @param token The bot's token
 * @param options A number of options to pass to the created API client
 * @param webhookReplyEnvelope The webhook reply envelope that will be used
 */
function createRawApi(token, options, webhookReplyEnvelope) {
    const client = new ApiClient(token, options, webhookReplyEnvelope);
    const proxyHandler = {
        get(_, m) {
            return m === "toJSON"
                ? "__internal"
                : client.callApi.bind(client, m);
        },
        ...proxyMethods,
    };
    const raw = new Proxy({}, proxyHandler);
    const installedTransformers = client.installedTransformers;
    const api = {
        raw,
        installedTransformers,
        use: (...t) => {
            client.use(...t);
            return api;
        },
    };
    return api;
}
exports.createRawApi = createRawApi;
const proxyMethods = {
    set() {
        return false;
    },
    defineProperty() {
        return false;
    },
    deleteProperty() {
        return false;
    },
    ownKeys() {
        return [];
    },
};
function isTelegramError(err) {
    return (typeof err === "object" &&
        err !== null &&
        "status" in err &&
        "statusText" in err);
}
function toHttpError(method, sensitiveLogs, reject) {
    return (err) => {
        let msg = `Network request for '${method}' failed!`;
        if (isTelegramError(err))
            msg += ` (${err.status}: ${err.statusText})`;
        if (sensitiveLogs && err instanceof Error)
            msg += ` ${err.message}`;
        reject(new error_js_1.HttpError(msg, err));
    };
}
function combineAborts(abortController, signal) {
    if (signal === undefined)
        return () => abortController.abort();
    const sig = signal;
    function abort() {
        abortController.abort();
        sig.removeEventListener("abort", abort);
    }
    if (sig.aborted)
        abort();
    else
        sig.addEventListener("abort", abort);
    return abort;
}
const shim_node_js_1 = require("../shim.node.js");
